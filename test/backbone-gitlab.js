// Generated by CoffeeScript 1.6.3
(function() {
  window.GitLab = {};

  GitLab.url = null;

  GitLab.sync = function(method, model, options) {
    var extendedOptions;
    extendedOptions = void 0;
    extendedOptions = _.extend({
      beforeSend: function(xhr) {
        if (GitLab.token) {
          return xhr.setRequestHeader("PRIVATE-TOKEN", GitLab.token);
        }
      }
    }, options);
    return Backbone.sync(method, model, extendedOptions);
  };

  GitLab.Model = Backbone.Model.extend({
    sync: GitLab.sync
  });

  GitLab.Collection = Backbone.Collection.extend({
    sync: GitLab.sync
  });

  GitLab.User = GitLab.Model.extend({
    backboneClass: "User",
    url: function() {
      return "" + GitLab.url + "/user";
    },
    initialize: function() {
      return this.sshkeys = new GitLab.SSHKeys();
    }
  });

  GitLab.SSHKey = GitLab.Model.extend({
    backboneClass: "SSHKey"
  });

  GitLab.SSHKeys = GitLab.Collection.extend({
    backboneClass: "SSHKeys",
    url: function() {
      return "" + GitLab.url + "/user/keys";
    },
    model: GitLab.SSHKey
  });

  GitLab.Project = GitLab.Model.extend({
    backboneClass: "Project",
    url: function() {
      return "" + GitLab.url + "/projects/" + (this.id || this.escaped_path());
    },
    initialize: function() {
      this.branches = new GitLab.Branches([], {
        project: this
      });
      this.members = new GitLab.Members([], {
        project: this
      });
      this.on("change", this.parsePath);
      return this.parse_path();
    },
    tree: function(path, branch) {
      return new GitLab.Tree([], {
        project: this,
        path: path,
        branch: branch
      });
    },
    blob: function(path, branch) {
      return new GitLab.Blob({
        file_path: path
      }, {
        branch: branch,
        project: this
      });
    },
    parse_path: function() {
      var split;
      if (this.get("path_with_namespace")) {
        split = this.get("path_with_namespace").split("/");
        this.set("path", _.last(split));
        return this.set("owner", {
          username: _.first(split)
        });
      }
    },
    escaped_path: function() {
      return this.get("path_with_namespace").replace("/", "%2F");
    }
  });

  GitLab.Branch = GitLab.Model.extend({
    backboneClass: "Branch"
  });

  GitLab.Branches = GitLab.Collection.extend({
    backboneClass: "Branches",
    model: GitLab.Branch,
    url: function() {
      return "" + GitLab.url + "/projects/" + (this.project.escaped_path()) + "/repository/branches";
    },
    initialize: function(models, options) {
      options = options || {};
      if (!options.project) {
        throw "You have to initialize GitLab.Branches with a GitLab.Project model";
      }
      return this.project = options.project;
    }
  });

  GitLab.Member = GitLab.Model.extend({
    backboneClass: "Member"
  });

  GitLab.Members = GitLab.Collection.extend({
    backboneClass: "Members",
    url: function() {
      return "" + GitLab.url + "/projects/" + (this.project.escaped_path()) + "/members";
    },
    initialize: function(models, options) {
      options = options || {};
      if (!options.project) {
        throw "You have to initialize GitLab.Members with a GitLab.Project model";
      }
      return this.project = options.project;
    },
    model: GitLab.Member
  });

  GitLab.Tree = GitLab.Collection.extend({
    backboneClass: "Tree",
    model: GitLab.Blob,
    url: function() {
      return "" + GitLab.url + "/projects/" + (this.project.escaped_path()) + "/repository/tree";
    },
    initialize: function(models, options) {
      options = options || {};
      if (!options.project) {
        throw "You have to initialize GitLab.Tree with a GitLab.Project model";
      }
      this.project = options.project;
      this.path = options.path;
      this.branch = options.branch || "master";
      return this.trees = [];
    },
    fetch: function(options) {
      options = options || {};
      options.data = options.data || {};
      if (this.path) {
        options.data.path = this.path;
      }
      options.data.ref_name = this.branch;
      return GitLab.Collection.prototype.fetch.apply(this, [options]);
    },
    parse: function(resp, xhr) {
      var _this = this;
      _(resp).filter(function(obj) {
        return obj.type === "tree";
      }).map(function(obj) {
        return _this.trees.push(_this.project.tree(obj.name, _this.branch));
      });
      return _(resp).filter(function(obj) {
        return obj.type === "blob";
      }).map(function(obj) {
        var full_path;
        full_path = [];
        if (_this.path) {
          full_path.push(_this.path);
        }
        full_path.push(obj.name);
        return _this.project.blob(full_path.join("/"), _this.branch);
      });
    }
  });

  GitLab.Blob = GitLab.Model.extend({
    backboneClass: "Blob",
    initialize: function(data, options) {
      options = options || {};
      if (!options.project) {
        throw "You have to initialize GitLab.Blob with a GitLab.Project model";
      }
      this.project = options.project;
      this.branch = options.branch || "master";
      this.on("sync", function() {
        return this.set("id", "fakeIDtoenablePUT");
      });
      this.on("change", this.parseFilePath);
      return this.parseFilePath();
    },
    parseFilePath: function(model, options) {
      if (this.get("file_path")) {
        return this.set("name", _.last(this.get("file_path").split("/")));
      }
    },
    sync: function(method, model, options) {
      var baseURL;
      options = options || {};
      baseURL = "" + GitLab.url + "/projects/" + (this.project.escaped_path()) + "/repository";
      if (method.toLowerCase() === "read") {
        options.url = "" + baseURL + "/blobs/" + this.branch;
      } else {
        options.url = "" + baseURL + "/files";
      }
      return GitLab.sync.apply(this, arguments);
    },
    toJSON: function() {
      return {
        file_path: this.get("file_path"),
        branch_name: this.branch,
        content: this.get("content"),
        commit_message: this.get("commit_message") || this.defaultCommitMessage()
      };
    },
    defaultCommitMessage: function() {
      if (this.isNew()) {
        return "Created " + (this.get("file_path"));
      } else {
        return "Updated " + (this.get("file_path"));
      }
    },
    fetchContent: function(options) {
      return this.fetch(_.extend({
        dataType: "html",
        data: {
          filepath: this.get("file_path")
        }
      }, options));
    },
    parse: function(response, options) {
      if (_.isString(response)) {
        return {
          content: response
        };
      } else {
        return response;
      }
    }
  });

  GitLab.Client = function(token) {
    this.token = token;
    this.user = new GitLab.User();
    this.project = function(full_path) {
      return new GitLab.Project({
        path: full_path.split("/")[1],
        path_with_namespace: full_path
      });
    };
    return this;
  };

}).call(this);
